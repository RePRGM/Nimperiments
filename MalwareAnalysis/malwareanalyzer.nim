# malware_analyzer.nim - A CAPA-like malware analysis framework
import pefile, tables, sets, strutils, sequtils, json, re, os, times, md5, base64

type
  # Rule types for capability detection
  RuleType* = enum
    rtImport      # Check for specific imports
    rtExport      # Check for specific exports
    rtString      # Check for strings in binary
    rtSection     # Check section characteristics
    rtEntropy     # Check entropy levels
    rtPattern     # Check for byte patterns
    rtPEAnomaly   # Check for PE structure anomalies
    rtBehavior    # Behavioral indicators
  
  RuleMatch* = object
    ruleName*: string
    ruleType*: RuleType
    confidence*: float  # 0.0 to 1.0
    description*: string
    iocs*: seq[string]  # Indicators of compromise
    
  Rule* = object
    name*: string
    ruleType*: RuleType
    description*: string
    severity*: string  # low, medium, high, critical
    tags*: seq[string]
    condition*: JsonNode  # Rule conditions in JSON format
    
  AnalysisResult* = object
    filePath*: string
    md5Hash*: string
    sha256Hash*: string
    fileSize*: int64
    isPacked*: bool
    entropy*: float
    architecture*: string
    compiletime*: DateTime
    matches*: seq[RuleMatch]
    capabilities*: Table[string, seq[string]]
    riskScore*: int  # 0-100
    
  MalwareAnalyzer* = ref object
    rules*: seq[Rule]
    peFile*: PEFile

# Utility functions
proc calculateEntropy(data: openArray[byte]): float =
  ## Calculate Shannon entropy
  var freq: array[256, int]
  for b in data:
    inc freq[b]
  
  result = 0.0
  let dataLen = float(data.len)
  for count in freq:
    if count > 0:
      let probability = float(count) / dataLen
      result -= probability * log2(probability)

proc findStrings(data: openArray[byte], minLength: int = 4): seq[string] =
  ## Extract ASCII and Unicode strings
  result = @[]
  var current = ""
  
  # ASCII strings
  for b in data:
    if b >= 32 and b <= 126:  # Printable ASCII
      current.add(char(b))
    else:
      if current.len >= minLength:
        result.add(current)
      current = ""
  if current.len >= minLength:
    result.add(current)
  
  # Simple Unicode string detection (UTF-16LE)
  current = ""
  var i = 0
  while i < data.len - 1:
    if data[i] >= 32 and data[i] <= 126 and data[i + 1] == 0:
      current.add(char(data[i]))
      i += 2
    else:
      if current.len >= minLength:
        result.add(current)
      current = ""
      i += 1
  if current.len >= minLength:
    result.add(current)

proc searchPattern(data: openArray[byte], pattern: openArray[byte]): seq[int] =
  ## Find byte pattern in data
  result = @[]
  if pattern.len == 0 or pattern.len > data.len:
    return
  
  for i in 0..(data.len - pattern.len):
    var found = true
    for j, b in pattern:
      if data[i + j] != b:
        found = false
        break
    if found:
      result.add(i)

# Rule checking functions
proc checkImportRule(pe: PEFile, condition: JsonNode): tuple[matched: bool, iocs: seq[string]] =
  ## Check import-based rules
  result.matched = false
  result.iocs = @[]
  
  if condition.hasKey("dll"):
    let dll = condition["dll"].getStr().toLowerAscii()
    if pe.hasImport(dll):
      result.matched = true
      result.iocs.add("Import: " & dll)
      
      if condition.hasKey("functions"):
        let funcs = pe.getImportedFunctions(dll)
        for funcPattern in condition["functions"]:
          let pattern = funcPattern.getStr()
          for f in funcs:
            if pattern in f.toLowerAscii():
              result.iocs.add("Function: " & dll & "!" & f)

proc checkStringRule(pe: PEFile, condition: JsonNode): tuple[matched: bool, iocs: seq[string]] =
  ## Check for specific strings
  result.matched = false
  result.iocs = @[]
  
  let strings = findStrings(pe.data)
  let patterns = condition["patterns"].getElems()
  
  for pattern in patterns:
    let p = pattern.getStr()
    for s in strings:
      if p in s.toLowerAscii():
        result.matched = true
        result.iocs.add("String: " & s[0..min(50, s.len-1)])

proc checkSectionRule(pe: PEFile, condition: JsonNode): tuple[matched: bool, iocs: seq[string]] =
  ## Check section characteristics
  result.matched = false
  result.iocs = @[]
  
  for section in pe.sections:
    let name = section.getSectionName()
    
    # Check for unusual section names
    if condition.hasKey("unusual_names"):
      let unusual = condition["unusual_names"].getElems()
      for u in unusual:
        if name == u.getStr():
          result.matched = true
          result.iocs.add("Unusual section: " & name)
    
    # Check for RWX sections (suspicious)
    if condition.hasKey("check_rwx") and condition["check_rwx"].getBool():
      const
        IMAGE_SCN_MEM_EXECUTE = 0x20000000'u32
        IMAGE_SCN_MEM_WRITE = 0x80000000'u32
        IMAGE_SCN_MEM_READ = 0x40000000'u32
      
      let chars = section.characteristics
      if (chars and IMAGE_SCN_MEM_EXECUTE) != 0 and
         (chars and IMAGE_SCN_MEM_WRITE) != 0:
        result.matched = true
        result.iocs.add("RWX Section: " & name)
    
    # Check entropy
    if condition.hasKey("high_entropy"):
      let threshold = condition["high_entropy"].getFloat()
      let sectionData = pe.readDataAt(section.pointerToRawData, 
                                      min(int(section.sizeOfRawData), 1024*1024))
      let entropy = calculateEntropy(sectionData)
      if entropy > threshold:
        result.matched = true
        result.iocs.add("High entropy section: " & name & 
                       " (entropy: " & $entropy.formatFloat(ffDecimal, 2) & ")")

proc checkPEAnomalyRule(pe: PEFile, condition: JsonNode): tuple[matched: bool, iocs: seq[string]] =
  ## Check for PE structure anomalies
  result.matched = false
  result.iocs = @[]
  
  # Check for suspicious entry point
  if condition.hasKey("suspicious_entrypoint"):
    let ep = pe.getEntryPoint()
    var epInSection = false
    
    for section in pe.sections:
      if ep >= section.virtualAddress and 
         ep < section.virtualAddress + section.virtualSize:
        epInSection = true
        let name = section.getSectionName()
        if name notin [".text", ".code", "CODE", "TEXT"]:
          result.matched = true
          result.iocs.add("Entry point in unusual section: " & name)
        break
    
    if not epInSection:
      result.matched = true
      result.iocs.add("Entry point outside any section")
  
  # Check for overlapping sections
  if condition.hasKey("check_overlapping") and condition["check_overlapping"].getBool():
    for i, s1 in pe.sections:
      for j, s2 in pe.sections:
        if i < j:
          # Check virtual address overlap
          if s1.virtualAddress < s2.virtualAddress + s2.virtualSize and
             s2.virtualAddress < s1.virtualAddress + s1.virtualSize:
            result.matched = true
            result.iocs.add("Overlapping sections: " & 
                           s1.getSectionName() & " and " & s2.getSectionName())
  
  # Check for suspicious timestamps
  if condition.hasKey("check_timestamp") and condition["check_timestamp"].getBool():
    let compileTime = pe.getCompileTime()
    let futureTime = now() + initDuration(days = 30)
    let ancientTime = fromUnix(0)
    
    if compileTime > futureTime:
      result.matched = true
      result.iocs.add("Future timestamp: " & $compileTime)
    elif compileTime < ancientTime + initDuration(days = 365):
      result.matched = true
      result.iocs.add("Suspicious timestamp: " & $compileTime)

# Main analyzer implementation
proc loadRules*(filename: string): seq[Rule] =
  ## Load rules from JSON file
  result = @[]
  let rulesJson = parseJson(readFile(filename))
  
  for ruleJson in rulesJson["rules"]:
    var rule = Rule(
      name: ruleJson["name"].getStr(),
      description: ruleJson["description"].getStr(),
      severity: ruleJson["severity"].getStr(),
      condition: ruleJson["condition"]
    )
    
    # Parse rule type
    case ruleJson["type"].getStr():
    of "import": rule.ruleType = rtImport
    of "export": rule.ruleType = rtExport
    of "string": rule.ruleType = rtString
    of "section": rule.ruleType = rtSection
    of "entropy": rule.ruleType = rtEntropy
    of "pattern": rule.ruleType = rtPattern
    of "pe_anomaly": rule.ruleType = rtPEAnomaly
    of "behavior": rule.ruleType = rtBehavior
    
    # Parse tags
    if ruleJson.hasKey("tags"):
      for tag in ruleJson["tags"]:
        rule.tags.add(tag.getStr())
    
    result.add(rule)

proc applyRule(analyzer: MalwareAnalyzer, rule: Rule): RuleMatch =
  ## Apply a single rule to the PE file
  var matched = false
  var iocs: seq[string] = @[]
  
  case rule.ruleType:
  of rtImport:
    (matched, iocs) = checkImportRule(analyzer.peFile, rule.condition)
  of rtString:
    (matched, iocs) = checkStringRule(analyzer.peFile, rule.condition)
  of rtSection:
    (matched, iocs) = checkSectionRule(analyzer.peFile, rule.condition)
  of rtPEAnomaly:
    (matched, iocs) = checkPEAnomalyRule(analyzer.peFile, rule.condition)
  else:
    discard  # Not implemented yet
  
  if matched:
    result = RuleMatch(
      ruleName: rule.name,
      ruleType: rule.ruleType,
      confidence: 0.8,  # Default confidence
      description: rule.description,
      iocs: iocs
    )

proc detectPacking(pe: PEFile): bool =
  ## Detect if file is likely packed
  # Check section names
  let suspiciousNames = [".upx", ".aspack", ".adata", ".petite", "pec2", ".rsrc"]
  for section in pe.sections:
    let name = section.getSectionName().toLowerAscii()
    if name in suspiciousNames:
      return true
  
  # Check entropy of first section
  if pe.sections.len > 0:
    let firstSection = pe.sections[0]
    let data = pe.readDataAt(firstSection.pointerToRawData, 
                             min(int(firstSection.sizeOfRawData), 1024*1024))
    if calculateEntropy(data) > 7.0:
      return true
  
  # Check if entry point is in last section
  if pe.sections.len > 0:
    let lastSection = pe.sections[^1]
    let ep = pe.getEntryPoint()
    if ep >= lastSection.virtualAddress and
       ep < lastSection.virtualAddress + lastSection.virtualSize:
      return true
  
  return false

proc analyzeCapabilities(matches: seq[RuleMatch]): Table[string, seq[string]] =
  ## Group matches into capabilities
  result = initTable[string, seq[string]]()
  
  for match in matches:
    var category = ""
    
    # Categorize based on rule type and name
    if "network" in match.ruleName.toLowerAscii() or
       "socket" in match.description.toLowerAscii() or
       "internet" in match.description.toLowerAscii():
      category = "Network Communication"
    elif "registry" in match.ruleName.toLowerAscii():
      category = "Registry Manipulation"
    elif "process" in match.ruleName.toLowerAscii() or
         "thread" in match.ruleName.toLowerAscii():
      category = "Process Manipulation"
    elif "file" in match.ruleName.toLowerAscii():
      category = "File System Operations"
    elif "crypt" in match.ruleName.toLowerAscii() or
         "encrypt" in match.description.toLowerAscii():
      category = "Cryptographic Operations"
    elif "anti" in match.ruleName.toLowerAscii():
      category = "Anti-Analysis Techniques"
    else:
      category = "Other Capabilities"
    
    if category notin result:
      result[category] = @[]
    result[category].add(match.description)

proc calculateRiskScore(matches: seq[RuleMatch], isPacked: bool): int =
  ## Calculate overall risk score (0-100)
  result = 0
  
  # Base score on number of matches
  result += min(matches.len * 5, 30)
  
  # Add points for critical matches
  for match in matches:
    if "critical" in match.description.toLowerAscii():
      result += 15
    elif "high" in match.description.toLowerAscii():
      result += 10
    elif "medium" in match.description.toLowerAscii():
      result += 5
  
  # Packed files are more suspicious
  if isPacked:
    result += 20
  
  result = min(result, 100)

proc analyze*(analyzer: MalwareAnalyzer, filepath: string): AnalysisResult =
  ## Perform comprehensive malware analysis
  analyzer.peFile = loadPEFile(filepath)
  let pe = analyzer.peFile
  
  result.filePath = filepath
  result.fileSize = getFileSize(filepath)
  result.architecture = pe.getMachineType()
  result.compiletime = pe.getCompileTime()
  
  # Calculate hashes
  let fileContent = readFile(filepath)
  result.md5Hash = getMD5(fileContent)
  # SHA256 would require additional crypto library
  
  # Calculate file entropy
  result.entropy = calculateEntropy(cast[seq[byte]](fileContent))
  
  # Detect packing
  result.isPacked = detectPacking(pe)
  
  # Apply all rules
  result.matches = @[]
  for rule in analyzer.rules:
    let match = analyzer.applyRule(rule)
    if match.ruleName != "":
      result.matches.add(match)
  
  # Analyze capabilities
  result.capabilities = analyzeCapabilities(result.matches)
  
  # Calculate risk score
  result.riskScore = calculateRiskScore(result.matches, result.isPacked)

proc generateReport*(result: AnalysisResult): string =
  ## Generate human-readable analysis report
  result = "=== Malware Analysis Report ===\n"
  result &= "File: " & result.filePath & "\n"
  result &= "MD5: " & result.md5Hash & "\n"
  result &= "Size: " & $result.fileSize & " bytes\n"
  result &= "Architecture: " & result.architecture & "\n"
  result &= "Compile Time: " & $result.compiletime & "\n"
  result &= "Entropy: " & result.entropy.formatFloat(ffDecimal, 2) & "\n"
  result &= "Packed: " & (if result.isPacked: "Yes (Suspicious)" else: "No") & "\n"
  result &= "Risk Score: " & $result.riskScore & "/100\n"
  
  if result.riskScore >= 70:
    result &= "Risk Level: HIGH - Likely malicious\n"
  elif result.riskScore >= 40:
    result &= "Risk Level: MEDIUM - Potentially suspicious\n"
  else:
    result &= "Risk Level: LOW - Probably benign\n"
  
  result &= "\n=== Detected Capabilities ===\n"
  for category, capabilities in result.capabilities:
    result &= "\n" & category & ":\n"
    for cap in capabilities:
      result &= "  â€¢ " & cap & "\n"
  
  result &= "\n=== Detailed Findings ===\n"
  for match in result.matches:
    result &= "\nRule: " & match.ruleName & "\n"
    result &= "Type: " & $match.ruleType & "\n"
    result &= "Description: " & match.description & "\n"
    if match.iocs.len > 0:
      result &= "Indicators:\n"
      for ioc in match.iocs:
        result &= "  - " & ioc & "\n"

proc exportToJSON*(result: AnalysisResult): string =
  ## Export analysis result to JSON format
  let j = %* {
    "file": result.filePath,
    "hashes": {
      "md5": result.md5Hash,
      "sha256": result.sha256Hash
    },
    "fileSize": result.fileSize,
    "entropy": result.entropy,
    "packed": result.isPacked,
    "architecture": result.architecture,
    "compileTime": $result.compiletime,
    "riskScore": result.riskScore,
    "capabilities": result.capabilities,
    "matches": result.matches.mapIt(%* {
      "rule": it.ruleName,
      "type": $it.ruleType,
      "confidence": it.confidence,
      "description": it.description,
      "iocs": it.iocs
    })
  }
  return j.pretty()

# Example usage
when isMainModule:
  # Create analyzer
  var analyzer = MalwareAnalyzer()
  
  # Load rules (would normally load from file)
  analyzer.rules = @[
    Rule(
      name: "suspicious_imports",
      ruleType: rtImport,
      description: "Uses process injection APIs",
      severity: "high",
      condition: %* {"dll": "kernel32.dll", "functions": ["WriteProcessMemory", "CreateRemoteThread"]}
    ),
    Rule(
      name: "network_activity",
      ruleType: rtImport,
      description: "Network communication capability",
      severity: "medium",
      condition: %* {"dll": "ws2_32.dll"}
    ),
    Rule(
      name: "packed_section",
      ruleType: rtSection,
      description: "Contains high entropy section (possibly packed)",
      severity: "medium",
      condition: %* {"high_entropy": 7.0}
    ),
    Rule(
      name: "suspicious_section",
      ruleType: rtSection,
      description: "Contains writable and executable section",
      severity: "high",
      condition: %* {"check_rwx": true}
    ),
    Rule(
      name: "pe_anomalies",
      ruleType: rtPEAnomaly,
      description: "PE structure anomalies detected",
      severity: "medium",
      condition: %* {"suspicious_entrypoint": true, "check_timestamp": true}
    )
  ]
  
  if paramCount() < 1:
    echo "Usage: ", paramStr(0), " <PE file>"
    quit(1)
  
  try:
    let result = analyzer.analyze(paramStr(1))
    echo generateReport(result)
    
    # Optionally save JSON report
    if paramCount() > 1 and paramStr(2) == "--json":
      writeFile(paramStr(1) & ".analysis.json", exportToJSON(result))
      echo "\nJSON report saved to: ", paramStr(1) & ".analysis.json"
  except:
    echo "Error analyzing file: ", getCurrentExceptionMsg()
