# advanced_malware_analyzer.nim - Extended features for malware analysis
#
# This module provides advanced analysis features that extend
# the basic malware_analyzer functionality
#
# To compile as standalone:
#   nim c -d:release advanced_malware_analyzer.nim
#
import tables, sets, strutils, sequtils, json, os, times, math
import pefile

# Import calculateEntropy if it's exported from malware_analyzer
# Otherwise, redefine it here
proc calculateEntropy*(data: openArray[byte]): float =
  ## Calculate Shannon entropy
  if data.len == 0:
    return 0.0
    
  var freq: array[256, int]
  for b in data:
    inc freq[b]
  
  result = 0.0
  let dataLen = float(data.len)
  for count in freq:
    if count > 0:
      let probability = float(count) / dataLen
      result -= probability * log2(probability)

type

type
  # YARA-like pattern matching
  YaraPattern* = object
    name*: string
    patterns*: seq[string]  # Hex patterns
    strings*: seq[string]   # Text strings
    condition*: string      # Logical condition
    
  # Behavioral indicators
  BehaviorIndicator* = object
    category*: string
    behavior*: string
    confidence*: float
    evidence*: seq[string]
  
  # Basic types needed from malware_analyzer
  RuleMatch* = object
    ruleName*: string
    ruleType*: string
    confidence*: float
    description*: string
    iocs*: seq[string]
    
  AnalysisResult* = object
    filePath*: string
    md5Hash*: string
    sha256Hash*: string
    fileSize*: int64
    isPacked*: bool
    entropy*: float
    architecture*: string
    compiletime*: DateTime
    matches*: seq[RuleMatch]
    capabilities*: Table[string, seq[string]]
    riskScore*: int
    
  # Extended analysis result
  ExtendedAnalysisResult* = object
    basic*: AnalysisResult
    yaraMatches*: seq[string]
    behaviors*: seq[BehaviorIndicator]
    apiSequences*: seq[seq[string]]
    suspiciousPatterns*: Table[string, int]
    similarityScore*: Table[string, float]  # Similarity to known malware

# Pattern matching engine
proc hexStringToBytes(hexStr: string): seq[byte] =
  ## Convert hex string to bytes (supports wildcards)
  result = @[]
  var i = 0
  let cleaned = hexStr.replace(" ", "").replace("\n", "")
  
  while i < cleaned.len - 1:
    if cleaned[i] == '?' and cleaned[i+1] == '?':
      result.add(0xFF'u8)  # Wildcard marker
      i += 2
    else:
      let byteStr = cleaned[i..i+1]
      result.add(parseHexInt(byteStr).byte)
      i += 2

proc matchPattern(data: openArray[byte], pattern: seq[byte], offset: int = 0): bool =
  ## Match pattern with wildcard support
  if offset + pattern.len > data.len:
    return false
    
  for i, p in pattern:
    if p != 0xFF and data[offset + i] != p:  # 0xFF is wildcard
      return false
  return true

proc findPattern(data: openArray[byte], pattern: seq[byte]): seq[int] =
  ## Find all occurrences of pattern
  result = @[]
  for i in 0..(data.len - pattern.len):
    if matchPattern(data, pattern, i):
      result.add(i)

# Behavioral analysis
proc analyzeAPISequences(pe: PEFile): seq[seq[string]] =
  ## Extract suspicious API call sequences
  result = @[]
  var allAPIs: seq[string] = @[]
  
  # Collect all imported functions
  for dll, functions in pe.imports:
    for fn in functions:
      allAPIs.add(dll & "!" & fn)
  
  # Look for suspicious sequences
  let suspiciousSequences = @[
    @["kernel32.dll!VirtualAlloc", "kernel32.dll!WriteProcessMemory", "kernel32.dll!CreateRemoteThread"],
    @["kernel32.dll!OpenProcess", "ntdll.dll!NtWriteVirtualMemory"],
    @["advapi32.dll!RegOpenKeyEx", "advapi32.dll!RegSetValueEx"],
    @["ws2_32.dll!socket", "ws2_32.dll!connect", "ws2_32.dll!send"],
    @["user32.dll!GetAsyncKeyState", "kernel32.dll!WriteFile"]
  ]
  
  for sequence in suspiciousSequences:
    var found = true
    for api in sequence:
      if api notin allAPIs:
        found = false
        break
    if found:
      result.add(sequence)

proc detectBehaviors(pe: PEFile, matches: seq[RuleMatch]): seq[BehaviorIndicator] =
  ## Detect behavioral patterns
  result = @[]
  
  # Check for process hollowing indicators
  let hollowingAPIs = ["NtUnmapViewOfSection", "WriteProcessMemory", "SetThreadContext"]
  var hollowingCount = 0
  var evidence: seq[string] = @[]
  
  for dll, functions in pe.imports:
    for fn in functions:
      if fn in hollowingAPIs:
        inc hollowingCount
        evidence.add(dll & "!" & fn)
  
  if hollowingCount >= 2:
    result.add(BehaviorIndicator(
      category: "Code Injection",
      behavior: "Process Hollowing",
      confidence: float(hollowingCount) / 3.0,
      evidence: evidence
    ))
  
  # Check for anti-analysis behaviors
  let antiAnalysisAPIs = [
    "IsDebuggerPresent", "CheckRemoteDebuggerPresent",
    "GetTickCount", "QueryPerformanceCounter",
    "NtQueryInformationProcess", "NtSetInformationThread"
  ]
  
  var antiAnalysisCount = 0
  evidence = @[]
  
  for dll, functions in pe.imports:
    for fn in functions:
      if fn in antiAnalysisAPIs:
        inc antiAnalysisCount
        evidence.add(dll & "!" & fn)
  
  if antiAnalysisCount >= 2:
    result.add(BehaviorIndicator(
      category: "Evasion",
      behavior: "Anti-Analysis Techniques",
      confidence: min(float(antiAnalysisCount) / 4.0, 1.0),
      evidence: evidence
    ))
  
  # Check for data exfiltration patterns
  let networkAPIs = ["send", "InternetWriteFile", "HttpSendRequest", "WSASend"]
  let fileAPIs = ["ReadFile", "CreateFile", "FindFirstFile", "FindNextFile"]
  
  var hasNetwork = false
  var hasFileEnum = false
  
  for dll, functions in pe.imports:
    for fn in functions:
      if fn in networkAPIs:
        hasNetwork = true
      if fn in fileAPIs:
        hasFileEnum = true
  
  if hasNetwork and hasFileEnum:
    result.add(BehaviorIndicator(
      category: "Data Theft",
      behavior: "Potential Data Exfiltration",
      confidence: 0.7,
      evidence: @["Network + File enumeration APIs present"]
    ))

proc calculateSimilarity(pe1, pe2: PEFile): float =
  ## Calculate similarity between two PE files
  # Simple implementation - can be enhanced with fuzzy hashing
  var matchCount = 0
  var totalChecks = 0
  
  # Compare imports
  for dll, _ in pe1.imports:
    inc totalChecks
    if pe2.imports.hasKey(dll):
      inc matchCount
  
  # Compare section names
  let sections1 = pe1.sections.mapIt(it.getSectionName())
  let sections2 = pe2.sections.mapIt(it.getSectionName())
  
  for s in sections1:
    inc totalChecks
    if s in sections2:
      inc matchCount
  
  # Compare file characteristics
  inc totalChecks
  if pe1.fileHeader.characteristics == pe2.fileHeader.characteristics:
    inc matchCount
  
  if totalChecks > 0:
    result = float(matchCount) / float(totalChecks)
  else:
    result = 0.0

# Machine learning features extraction
proc extractMLFeatures(pe: PEFile): seq[float] =
  ## Extract features for ML-based detection
  result = @[]
  
  # File characteristics
  result.add(float(pe.fileHeader.numberOfSections))
  result.add(float(pe.fileHeader.sizeOfOptionalHeader))
  result.add(float(pe.imports.len))
  
  # Section features
  var totalSectionSize = 0'u32
  var executableSections = 0
  const IMAGE_SCN_MEM_EXECUTE = 0x20000000'u32
  
  for section in pe.sections:
    totalSectionSize += section.sizeOfRawData
    if (section.characteristics and IMAGE_SCN_MEM_EXECUTE) != 0:
      inc executableSections
  
  result.add(float(totalSectionSize))
  result.add(float(executableSections))
  
  # Import diversity
  var uniqueAPIs = 0
  for _, functions in pe.imports:
    uniqueAPIs += functions.len
  result.add(float(uniqueAPIs))
  
  # Entropy features
  if pe.sections.len > 0:
    let firstSection = pe.sections[0]
    let data = pe.readDataAt(firstSection.pointerToRawData, 
                             min(int(firstSection.sizeOfRawData), 1024))
    result.add(calculateEntropy(data))
  else:
    result.add(0.0)

# CAPA-like capability extraction
proc extractCapabilities(pe: PEFile): Table[string, seq[string]] =
  ## Extract high-level capabilities similar to CAPA
  result = initTable[string, seq[string]]()
  
  # File manipulation
  let fileAPIs = ["CreateFile", "WriteFile", "ReadFile", "DeleteFile", "MoveFile"]
  var fileCaps: seq[string] = @[]
  for dll, functions in pe.imports:
    for fn in functions:
      if fn in fileAPIs:
        fileCaps.add("Can " & fn.replace("File", " files"))
  if fileCaps.len > 0:
    result["File Operations"] = fileCaps.deduplicate()
  
  # Network capabilities
  let networkCaps = {
    "socket": "Create network connections",
    "connect": "Connect to remote servers",
    "send": "Send data over network",
    "recv": "Receive data from network",
    "InternetOpen": "Access internet resources",
    "HttpSendRequest": "Make HTTP requests",
    "DnsQuery": "Perform DNS lookups"
  }.toTable()
  
  var netCaps: seq[string] = @[]
  for dll, functions in pe.imports:
    for fn in functions:
      if fn in networkCaps:
        netCaps.add(networkCaps[fn])
  if netCaps.len > 0:
    result["Network Communication"] = netCaps.deduplicate()
  
  # Process manipulation
  let processCaps = {
    "CreateProcess": "Create new processes",
    "OpenProcess": "Open existing processes",
    "TerminateProcess": "Terminate processes",
    "WriteProcessMemory": "Modify process memory",
    "CreateRemoteThread": "Create threads in other processes",
    "EnumProcesses": "Enumerate running processes"
  }.toTable()
  
  var procCaps: seq[string] = @[]
  for dll, functions in pe.imports:
    for fn in functions:
      if fn in processCaps:
        procCaps.add(processCaps[fn])
  if procCaps.len > 0:
    result["Process Manipulation"] = procCaps.deduplicate()

# Signature generation
proc generateSignature(pe: PEFile): string =
  ## Generate a unique signature for the malware
  result = "malware."
  
  # Add architecture
  result &= pe.getMachineType().toLowerAscii() & "."
  
  # Add key imports
  var keyImports: seq[string] = @[]
  for dll, _ in pe.imports:
    if dll in ["ws2_32.dll", "wininet.dll"]:
      keyImports.add("net")
    elif dll in ["advapi32.dll", "crypt32.dll"]:
      keyImports.add("crypto")
  
  result &= keyImports.deduplicate().join("_")
  
  # Add section hash (simplified)
  if pe.sections.len > 0:
    result &= "." & $pe.sections.len & "sec"

# Report generation with graphs
proc generateHTMLReport(analysis: ExtendedAnalysisResult): string =
  ## Generate an HTML report with visualizations
  var output = """
<!DOCTYPE html>
<html>
<head>
  <title>Malware Analysis Report</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    .header { background: #2c3e50; color: white; padding: 20px; }
    .section { margin: 20px 0; padding: 10px; border: 1px solid #ddd; }
    .high { color: #e74c3c; }
    .medium { color: #f39c12; }
    .low { color: #27ae60; }
    .indicator { margin: 5px 0; padding: 5px; background: #ecf0f1; }
    table { border-collapse: collapse; width: 100%; }
    th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
    th { background: #34495e; color: white; }
  </style>
</head>
<body>
  <div class="header">
    <h1>Malware Analysis Report</h1>
    <p>Generated: """ & $now() & """</p>
  </div>
"""
  
  # Basic information
  output &= """
  <div class="section">
    <h2>File Information</h2>
    <table>
      <tr><td>File</td><td>""" & analysis.basic.filePath & """</td></tr>
      <tr><td>MD5</td><td>""" & analysis.basic.md5Hash & """</td></tr>
      <tr><td>Size</td><td>""" & $analysis.basic.fileSize & """ bytes</td></tr>
      <tr><td>Architecture</td><td>""" & analysis.basic.architecture & """</td></tr>
      <tr><td>Compile Time</td><td>""" & $analysis.basic.compiletime & """</td></tr>
      <tr><td>Entropy</td><td>""" & $analysis.basic.entropy & """</td></tr>
      <tr><td>Risk Score</td><td class='""" & 
        (if analysis.basic.riskScore >= 70: "high" 
         elif analysis.basic.riskScore >= 40: "medium" 
         else: "low") & """'>""" & $analysis.basic.riskScore & """/100</td></tr>
    </table>
  </div>
"""
  
  # Behavioral analysis
  if analysis.behaviors.len > 0:
    output &= """
  <div class="section">
    <h2>Behavioral Analysis</h2>
"""
    for behavior in analysis.behaviors:
      output &= """
    <div class="indicator">
      <strong>""" & behavior.behavior & """</strong> (""" & behavior.category & """)
      <br>Confidence: """ & formatFloat(behavior.confidence * 100.0, ffDecimal, 0) & """%
      <br>Evidence: """ & behavior.evidence.join(", ") & """
    </div>
"""
    output &= "</div>"
  
  # Capabilities
  if analysis.basic.capabilities.len > 0:
    output &= """
  <div class="section">
    <h2>Detected Capabilities</h2>
    <ul>
"""
    for category, caps in analysis.basic.capabilities:
      output &= "<li><strong>" & category & "</strong><ul>"
      for cap in caps:
        output &= "<li>" & cap & "</li>"
      output &= "</ul></li>"
    output &= """
    </ul>
  </div>
"""
  
  output &= """
</body>
</html>
"""
  return output

# Example advanced usage
when isMainModule:
  if paramCount() < 1:
    echo "Usage: ", paramStr(0), " <PE file> [--html]"
    quit(1)
  
  try:
    # Create analyzers
    var analyzer = MalwareAnalyzer()
    
    # Load rules from file or use defaults
    if fileExists("rules.json"):
      analyzer.rules = loadRules("rules.json")
    
    # Perform basic analysis
    let basicResult = analyzer.analyze(paramStr(1))
    
    # Extended analysis
    var extResult = ExtendedAnalysisResult(basic: basicResult)
    
    # Behavioral analysis
    extResult.behaviors = detectBehaviors(analyzer.peFile, basicResult.matches)
    
    # API sequence analysis
    extResult.apiSequences = analyzeAPISequences(analyzer.peFile)
    
    # Extract capabilities
    let capabilities = extractCapabilities(analyzer.peFile)
    
    # Generate report
    if paramCount() > 1 and paramStr(2) == "--html":
      writeFile(paramStr(1) & "_report.html", generateHTMLReport(extResult))
      echo "HTML report saved to: ", paramStr(1) & "_report.html"
    else:
      echo generateReport(basicResult)
      
    # Print behavioral analysis
    if extResult.behaviors.len > 0:
      echo "\n=== Behavioral Analysis ==="
      for b in extResult.behaviors:
        echo "\n", b.behavior, " (", b.category, ")"
        echo "Confidence: ", formatFloat(b.confidence * 100.0, ffDecimal, 0), "%"
        echo "Evidence: ", b.evidence.join(", ")
  
  except PEError as e:
    echo "PE Error: ", e.msg
  except IOError as e:
    echo "IO Error: ", e.msg
  except Exception as e:
    echo "Error: ", e.msg
