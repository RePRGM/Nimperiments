# malware_scanner.nim - Complete malware scanning application
#
# This is a standalone scanner implementation that demonstrates
# the concepts from malware_analyzer.nim
#
# To compile:
#   nim c -d:release malware_scanner.nim
#
# For full functionality, use with malware_analyzer.nim
#
import os, strutils, times, json, tables
import pefile

# Note: In a real implementation, these types would be imported from malware_analyzer
# For now, we'll define the essential types here to avoid circular dependencies

type
  RuleType* = enum
    rtImport
    rtExport
    rtString
    rtSection
    rtEntropy
    rtPattern
    rtPEAnomaly
    rtBehavior
  
  RuleMatch* = object
    ruleName*: string
    ruleType*: RuleType
    confidence*: float
    description*: string
    iocs*: seq[string]
    
  Rule* = object
    name*: string
    ruleType*: RuleType
    description*: string
    severity*: string
    tags*: seq[string]
    condition*: JsonNode
    
  AnalysisResult* = object
    filePath*: string
    md5Hash*: string
    sha256Hash*: string
    fileSize*: int64
    isPacked*: bool
    entropy*: float
    architecture*: string
    compiletime*: DateTime
    matches*: seq[RuleMatch]
    capabilities*: Table[string, seq[string]]
    riskScore*: int
    
  MalwareAnalyzer* = ref object
    rules*: seq[Rule]
    peFile*: PEFile

  ScanResult* = object
    path*: string
    result*: AnalysisResult
    scanTime*: Duration
    error*: string

type
  ScanResult* = object
    path*: string
    result*: AnalysisResult
    scanTime*: Duration
    error*: string
    
  ScannerConfig* = object
    rulesPath*: string
    outputDir*: string
    generateReports*: bool
    jsonOutput*: bool
    htmlOutput*: bool
    verbose*: bool
    maxFileSize*: int64
    scanArchives*: bool
    quarantinePath*: string

# Placeholder for analysis function - in real use, import from malware_analyzer
proc analyze*(analyzer: MalwareAnalyzer, filepath: string): AnalysisResult =
  # This is a placeholder - the real implementation is in malware_analyzer.nim
  result.filePath = filepath
  result.fileSize = getFileSize(filepath)
  result.md5Hash = "placeholder_hash"
  result.sha256Hash = ""
  result.entropy = 0.0
  result.isPacked = false
  result.riskScore = 0
  result.matches = @[]
  result.capabilities = initTable[string, seq[string]]()
  
  # Basic PE analysis
  try:
    analyzer.peFile = loadPEFile(filepath)
    result.architecture = analyzer.peFile.getMachineType()
    result.compiletime = analyzer.peFile.getCompileTime()
  except:
    discard

proc loadRules*(filename: string): seq[Rule] =
  # Placeholder for rule loading
  result = @[]

proc exportToJSON*(analysisResult: AnalysisResult): string =
  # Convert analysis result to JSON
  let j = %* {
    "file": analysisResult.filePath,
    "md5": analysisResult.md5Hash,
    "fileSize": analysisResult.fileSize,
    "riskScore": analysisResult.riskScore
  }
  return j.pretty()

proc generateReport*(analysisResult: AnalysisResult): string =
  # Generate text report
  result = "File: " & analysisResult.filePath & "\n"
  result &= "Risk Score: " & $analysisResult.riskScore & "\n"

proc scanFile(analyzer: MalwareAnalyzer, filepath: string, config: ScannerConfig): ScanResult =
  ## Scan a single file
  result.path = filepath
  result.error = ""
  let startTime = now()
  
  try:
    # Check file size
    let fileSize = getFileSize(filepath)
    if fileSize > config.maxFileSize:
      result.error = "File too large: " & $fileSize & " bytes"
      result.scanTime = now() - startTime
      return
    
    # Perform analysis
    result.result = analyzer.analyze(filepath)
    result.scanTime = now() - startTime
    
    # Generate reports if requested
    if config.generateReports:
      let baseName = splitFile(filepath).name
      
      if config.jsonOutput:
        let jsonPath = config.outputDir / (baseName & "_analysis.json")
        writeFile(jsonPath, exportToJSON(result.result))
      
      if config.htmlOutput:
        # Would generate HTML report here
        discard
    
    # Quarantine if high risk
    if result.result.riskScore >= 80 and config.quarantinePath != "":
      let quarantineName = config.quarantinePath / (baseName & ".quarantine")
      moveFile(filepath, quarantineName)
      result.error = "File quarantined due to high risk score"
    
  except Exception as e:
    result.error = "Scan error: " & e.msg
    result.scanTime = now() - startTime

proc scanDirectory(analyzer: MalwareAnalyzer, dirPath: string, 
                  config: ScannerConfig, recursive: bool = true): seq[ScanResult] =
  ## Scan all PE files in a directory
  result = @[]
  
  for kind, path in walkDir(dirPath):
    case kind:
    of pcFile:
      let ext = splitFile(path).ext.toLowerAscii()
      if ext in [".exe", ".dll", ".sys", ".ocx", ".scr"]:
        if config.verbose:
          echo "Scanning: ", path
        result.add(scanFile(analyzer, path, config))
    of pcDir:
      if recursive:
        result &= scanDirectory(analyzer, path, config, recursive)
    else:
      discard

proc printScanSummary(results: seq[ScanResult]) =
  ## Print scan summary
  let totalFiles = results.len
  var maliciousFiles = 0
  var suspiciousFiles = 0
  var cleanFiles = 0
  var errors = 0
  var totalTime = initDuration()
  
  for r in results:
    totalTime = totalTime + r.scanTime
    if r.error != "":
      inc errors
    elif r.result.riskScore >= 70:
      inc maliciousFiles
    elif r.result.riskScore >= 40:
      inc suspiciousFiles
    else:
      inc cleanFiles
  
  echo "\n=== Scan Summary ==="
  echo "Total files scanned: ", totalFiles
  if totalFiles > 0:
    echo "Malicious files: ", maliciousFiles, " (", 
         formatFloat(float(maliciousFiles) / float(totalFiles) * 100.0, ffDecimal, 1), "%)"
    echo "Suspicious files: ", suspiciousFiles, " (",
         formatFloat(float(suspiciousFiles) / float(totalFiles) * 100.0, ffDecimal, 1), "%)"
    echo "Clean files: ", cleanFiles, " (",
         formatFloat(float(cleanFiles) / float(totalFiles) * 100.0, ffDecimal, 1), "%)"
  else:
    echo "No files scanned"
  echo "Errors: ", errors
  echo "Total scan time: ", totalTime
  echo "Average scan time: ", if totalFiles > 0: totalTime div totalFiles else: initDuration()

proc generateScanReport(results: seq[ScanResult], outputPath: string) =
  ## Generate comprehensive scan report
  var report = "=== Malware Scan Report ===\n"
  report &= "Generated: " & $now() & "\n"
  report &= "Total files scanned: " & $results.len & "\n\n"
  
  # High risk files
  report &= "=== High Risk Files ===\n"
  for r in results:
    if r.error == "" and r.result.riskScore >= 70:
      report &= "\nFile: " & r.path & "\n"
      report &= "Risk Score: " & $r.result.riskScore & "/100\n"
      report &= "MD5: " & r.result.md5Hash & "\n"
      
      # Top threats
      if r.result.matches.len > 0:
        report &= "Detected threats:\n"
        for i, match in r.result.matches:
          if i < 5:  # Top 5 threats
            report &= "  - " & match.description & "\n"
  
  # Summary by capability
  report &= "\n=== Detected Capabilities ===\n"
  var capabilityCounts = initTable[string, int]()
  
  for r in results:
    if r.error == "":
      for category, _ in r.result.capabilities:
        if capabilityCounts.hasKey(category):
          capabilityCounts[category] = capabilityCounts[category] + 1
        else:
          capabilityCounts[category] = 1
  
  for category, count in capabilityCounts:
    report &= category & ": " & $count & " files\n"
  
  writeFile(outputPath, report)

# Database integration for known malware
proc loadMalwareDatabase(dbPath: string): Table[string, string] =
  ## Load known malware hashes
  result = initTable[string, string]()
  if fileExists(dbPath):
    for line in lines(dbPath):
      let parts = line.split('\t')
      if parts.len >= 2:
        result[parts[0]] = parts[1]  # hash -> malware name

proc checkAgainstDatabase(md5Hash: string, db: Table[string, string]): string =
  ## Check if hash matches known malware
  if md5Hash in db:
    return db[md5Hash]
  return ""

# Main application
proc main() =
  echo """
  ╔══════════════════════════════════════╗
  ║     Nim Malware Scanner v1.0        ║
  ║   PE File Analysis & Detection      ║
  ╚══════════════════════════════════════╝
  """
  
  # Parse command line arguments
  if paramCount() < 1:
    echo "Usage: ", paramStr(0), " <file or directory> [options]"
    echo "\nOptions:"
    echo "  --rules <path>     Path to rules JSON file"
    echo "  --output <dir>     Output directory for reports"
    echo "  --json             Generate JSON reports"
    echo "  --html             Generate HTML reports"
    echo "  --verbose          Verbose output"
    echo "  --recursive        Scan directories recursively"
    echo "  --quarantine <dir> Move high-risk files to quarantine"
    echo "  --db <path>        Path to malware hash database"
    quit(1)
  
  # Configure scanner
  var config = ScannerConfig(
    rulesPath: "rules.json",
    outputDir: "reports",
    generateReports: false,
    jsonOutput: false,
    htmlOutput: false,
    verbose: false,
    maxFileSize: 100 * 1024 * 1024,  # 100MB
    scanArchives: false,
    quarantinePath: ""
  )
  
  var recursive = false
  var dbPath = ""
  var target = paramStr(1)
  
  # Parse options
  var i = 2
  while i <= paramCount():
    case paramStr(i):
    of "--rules":
      if i + 1 <= paramCount():
        config.rulesPath = paramStr(i + 1)
        i += 1
    of "--output":
      if i + 1 <= paramCount():
        config.outputDir = paramStr(i + 1)
        createDir(config.outputDir)
        config.generateReports = true
        i += 1
    of "--json":
      config.jsonOutput = true
      config.generateReports = true
    of "--html":
      config.htmlOutput = true
      config.generateReports = true
    of "--verbose":
      config.verbose = true
    of "--recursive":
      recursive = true
    of "--quarantine":
      if i + 1 <= paramCount():
        config.quarantinePath = paramStr(i + 1)
        createDir(config.quarantinePath)
        i += 1
    of "--db":
      if i + 1 <= paramCount():
        dbPath = paramStr(i + 1)
        i += 1
    inc i
  
  # Create analyzer
  var analyzer = MalwareAnalyzer()
  
  # Load rules
  if fileExists(config.rulesPath):
    echo "Loading rules from: ", config.rulesPath
    analyzer.rules = loadRules(config.rulesPath)
    echo "Loaded ", analyzer.rules.len, " rules"
  else:
    echo "Warning: Rules file not found, using default rules"
    # Load default rules as shown in previous examples
  
  # Load malware database
  var malwareDb: Table[string, string]
  if dbPath != "" and fileExists(dbPath):
    echo "Loading malware database: ", dbPath
    malwareDb = loadMalwareDatabase(dbPath)
    echo "Loaded ", malwareDb.len, " malware signatures"
  
  # Perform scan
  var results: seq[ScanResult] = @[]
  let startTime = now()
  
  if fileExists(target):
    # Single file scan
    echo "Scanning file: ", target
    results = @[scanFile(analyzer, target, config)]
  elif dirExists(target):
    # Directory scan
    echo "Scanning directory: ", target
    if recursive:
      echo "Recursive scan enabled"
    results = scanDirectory(analyzer, target, config, recursive)
  else:
    echo "Error: Target not found: ", target
    quit(1)
  
  let totalTime = now() - startTime
  
  # Check against malware database
  if malwareDb.len > 0:
    for i in 0..<results.len:
      if results[i].error == "":
        let knownMalware = checkAgainstDatabase(results[i].result.md5Hash, malwareDb)
        if knownMalware != "":
          results[i].result.riskScore = 100
          echo "\n!!! Known malware detected: ", knownMalware, " !!!"
          echo "File: ", results[i].path
  
  # Print results
  printScanSummary(results)
  
  # Print high-risk files
  echo "\n=== High Risk Files ==="
  for r in results:
    if r.error == "" and r.result.riskScore >= 70:
      echo "\n", r.path
      echo "  Risk Score: ", r.result.riskScore, "/100"
      echo "  MD5: ", r.result.md5Hash
      if r.result.matches.len > 0:
        echo "  Top threats:"
        for i, match in r.result.matches:
          if i < 3:
            echo "    - ", match.description
  
  # Generate final report
  if config.generateReports:
    let reportPath = config.outputDir / "scan_report.txt"
    generateScanReport(results, reportPath)
    echo "\nScan report saved to: ", reportPath
  
  echo "\nTotal scan time: ", totalTime

when isMainModule:
  main()
